#!/bin/bash -eu

################################################################################
# 
#       'bred++': A wrapper for 'bred' to cascade multiple 'bred' tasks
#
#                                                     dakusui@gmail.com
#
#  Mar/19/2015 Newly created.
# 
################################################################################

####
# Prints usage and exits with status code 2
usage() {
    echo "Usage: ${prog} "
    echo "       ${prog} -h for help."
    exit 2
}

####
# Writes a string to stderr
msg() {
    echo "${prog}: ${1}" >&2
}

####
# Writes a string to stderr and exit qith status code 1
quit() {
    msg "${1}"
    exit 1
}


####
# Reads stdin and forward it to stdout.
read_stdin() {
    while IFS="" read -r _line
    do
        echo "${_line}"
    done
}

####
# Prints the content of taskdef file specified by $2. 
# The taskdef should look like '{arg1};{arg2};...;{argn}:{taskdeffile}'
# And each arg looks like 'ENV_VAR=value'.
# Strings in the content which look like environment variables are 
# expanded by envsubst. This means even if you do not define environment variables 
# explicitly, ones you already have in your environment are expanded automatically.
# 
# In order to escape the expansion, you can do '${DOLLAR}SOME_ENV_VAR' instead of 
# '$SOME_ENV_VAR' in the content.
#
# $1 the directory from which the file is read if 'taskdeffile' portion
#    in taskdef doesn't start with '/'.
# $2 taskdef discussed above.
# 
# Limitation: taskdeffile portion can't contain a colon (:) 
read_taskfile() {
    local _dir=$1
    local _taskdef=$2
    local _filename="${_taskdef##*:}"
    if [[ "${_filename}" != "/"* ]]; then
	_filename="${_dir}/${_filename}"
    fi
    local _args=""
    if [[ "${_taskdef}" == *":"* ]]; then
	_args="${_taskdef%:*}"
    fi
    eval "cat ${_filename} | DOLLAR='$' BRED_SELF='${bredfile}' ${_args} envsubst"
}

####
# Reads 'task' field and print it. The field should look like 'file:...' or 'inline:...'.
# If the task starts with 'file:', read_taskfile will be performed.
# If it starts with 'inline:', the substring after the first colon will be printed.
# Otherwise exits with status code 1.
#
# $1 the task field's value 
# $2 the directory from which the file is read if the task field's scheme is 'file' 
#    and the path doesn't start with '/'.
#
# See also: read_task_file
read_task() {
    local _bredfile_dir="$2"
    local _ret=""
    case $1 in
	file:*)   _ret="'"$(read_taskfile "${_bredfile_dir}" "${1:5}")"'";;
	inline:*) _ret="${1:7}";;
	*)        echo "${prog}: line ${LINENO}: Unknown scheme is specified. (${1})" >&2 ; exit 1 ;;
    esac
    echo "$_ret"
}

read_bred_file() {
    local _tasknum=0
    local _id _type _sinks _key _interpreter _task
    firsttask=""
    while read -r _id _type _sinks _key _interpreter _task
    do 
	# Ignore records which start with '#'
	if [[ "$_id" == "#"* || -z "$_id" ]]; then
	    continue
	fi
	_task=$(read_task "${_task}" "${2}")
	msg "id=${_id},type=${_type},sinks=${_sinks},key=${_key},interpreter=${_interpreter},task=${_task}\n"
	if [ ${tasktype[${_id}]+_} ]; then
	    quit "line ${LINENO}: The key ${_id} is defined more than once"
	fi
	if [ ${_tasknum} == 0 ]; then
	    firsttask=${_id}
	fi
	tasktype[${_id}]=${_type}
	sinks[${_id}]=${_sinks//\;/ }
        key[${_id}]=${_key}
	interpreter[${_id}]=${_interpreter//\;/ }
	task[${_id}]=${_task}
	tasknum[${_id}]=${_tasknum}
	connected[${_id}]=""
	_tasknum=$((${_tasknum} + 1))
    done <"$1"
    if [ -z "${firsttask}" ]; then
	quit "line ${LINENO}: No task was found."  >&2
	exit 1
    fi
}

validate_bred_file_record() {
  # (t.b.d.)
  :
}

validate_bred_file() {
  # (t.b.d.)
    if [ ${_s} != '-' ] && [ ! -z "${connected[${_s}]}" ]; then
	quit "${prog}: line ${LINENO}: ${_s} is already connected to '${connected[${_s}]}'."
    fi
}

####
# Prints key of the first task referenced by task $1.
# If the task $1's has only one sink and it is '-'(stdout), 1 will be printed.
#
# $1 task id to be executed
nextkey() {
    if [ "${sinks[$1]}" == "-" ]; then
	echo 1
    else
	local _sinks
	local _k
	IFS=" " read -ra _sinks <<< "${sinks[${1}]}"
	_k="${_sinks[0]}"
	currentkey ${_k}
    fi
}

####
# Prints key for task specified by $1
#
# $1 task id to be executed
currentkey() {
    local _key="${key[${1}]}"
    if [ "${_key}" == "-" ]; then
	_key=1
    fi
    echo "${_key}"
}

####
# Prints a key converter command line.
# Returns 1 if key conversion is necessary, 0 otherwise.
#
# $1 source side task name
# $2 sink side task name
# $3 task id for keyconverter 
compose_keyconverter() {
    local _lofile="${logdir}/converter-${1}-${2}.log"
    if [ "${key[$1]}" == "${key[$2]}" ]; then
	echo ""
	return 0
    elif [ "${tasktype[$1]}" != "R" ]; then
	echo ""
	return 0
    else
	local _k1="${key[$1]}"
	if [[ "${_k1}" == "-" ]]; then
	    _k1=1
	fi
	local _k2="${key[$2]}"
	if [[ "${_k2}" == "-" ]]; then
	    _k2=1
	fi
	echo "bred -e ${_logfile} -j ${3} -c ${_k1} -s ${_k2} -M map -I \"sh -c\" -r 'cat'|"
	return 1
    fi
}

####
# Executes a task specified by $1. The output of the task is forwarded to stdout.
#
# $1 task id to be executed
exectask() {
    local _logfile="${logdir}/task-${1}.log"
    local _tasktype=${tasktype["${1}"]}
    local cmd=""
    # value ${task[${1}]} itself is already quoted, so we don't need to quote it in cmd again.
    if [[ "${_tasktype}" == "M" ]]; then
	cmd="bred -e ${_logfile} -c \"$(currentkey ${1})\" -s \"$(nextkey ${1})\" -M map -j \"${tasknum[${1}]}\" -I \"${interpreter[${1}]}\" -r ${task[${1}]}"
    elif [[ "${_tasktype}" == "R" ]]; then
	cmd="bred -e ${_logfile}  -c \"$(currentkey ${1})\" -s \"$(nextkey ${1})\" -M reduce -j \"${tasknum[${1}]}\" -I \"${interpreter[${1}]}\" -r ${task[${1}]}"
    elif [[ "${_tasktype}" == "L" ]]; then
	cmd="${interpreter[${1}]} ${task[${1}]}"
    else
	quit "${prog}: line ${LINENO}: Unknown task type ${_tasktype} was specified."
    fi
    cmd="BRED_SELF='${bredfile}' ${cmd}"
    msg "${cmd}"
    eval "${cmd}"
}

execstage() {
    local _i
    local _numsinks=0
    local _s
    local _sinks
    local _keyconverter_taskid="$2"
    # count number of sinks for this task
    IFS=" " read -ra _sinks <<< "${sinks[${1}]}"
    for _s in "${_sinks[@]}"; do
	if [ "${_s}" == "-" ]; then
	    : # stdout
	elif [ ! -z "${tasktype[${_s}]+_}" ]; then
	    : # cascaded task
	else
	    quit "${prog}: line ${LINENO}: No task ${_s} was found (referenced by task ${1})."
	fi
	_numsinks=$((_numsinks + 1))
    done
    if [[ "$_numsinks" -le 0 ]]; then
	quit "${prog}: line ${LINENO}: No sink was defined for task ${1}."
    elif [[ "$_numsinks" == 1 ]]; then
	if [ "${sinks[${1}]}" == "-" ]; then
	    # stdout
	    exectask "${1}" >> ${bredout} &
	else
	    # cascaded task
	    connected["${sinks[${1}]}"]="${1}"
	    exectask "${1}" | execstage "${sinks[${1}]}" "${_keyconverter_taskid}" &
	fi
    else
	local _tee="tee"
	# $_s for a sink
	for _s in "${_sinks[@]}"; do
	    local _keyconverter=$(compose_keyconverter "${1}" "${_s}" "${_keyconverter_taskid}")
	    _keyconverter_taskid=$((${_keyconverter_taskid} + 1))
	    _tee="${_tee} >(${_keyconverter} execstage ${_s} ${_keyconverter_taskid} > /dev/null)"
	    connected["${_s}"]="${1}"
	done
	exectask "${1}" | eval "${_tee} > /dev/null" &
    fi
}


main() {
    # global variables
    prog="`basename $0`"
    bredfile=$(readlink -e "${1}")
    bredtask=${2:-''}
    bredout="/tmp/bred++-`uuidgen`"
    logdir=${3:-$(pwd)}
    declare -A tasktype
    declare -A sinks
    declare -A key
    declare -A interpreter
    declare -A task
    declare -A tasknum
    declare -A connected

    # read records from job definition file
    read_bred_file "${bredfile}" $(dirname "$bredfile")
    firsttask=${bredtask:-${firsttask}}

    # start pipleline
    msg "starting pipeline"
    mkfifo "${bredout}"
    read_stdin | execstage "${firsttask}" 100
    cat "${bredout}"
    rm "${bredout}"
    msg "done"
}

main $@
